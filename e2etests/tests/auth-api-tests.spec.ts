import { test } from '../fixtures/api.fixture';
import { expect } from '@playwright/test';
import { AuthResponse, UsersResponse } from '../types/api-response.types';
import { generateRandomEmail } from '../utils/random-data-generator';

test.describe('Auth API tests @api_tests', { tag: '@api' }, () => {
  const email = process.env.DEFAULT_USER_EMAIL;
  const password = process.env.DEFAULT_USER_PASSWORD;
  const userId = process.env.DEFAULT_AUTH_USER_ID;

  test('Set verification codes', async ({ authRequest }) => {
    const response = await authRequest.setVerificationCode(email, '123456');

    await test.step('Verify response status and payload fields', async () => {
      expect(response.status()).toBe(201);
    });
  });

  test('Authorize user payload', async ({ authRequest }) => {
    const response = await authRequest.authorization(email, password);
    const payload = JSON.parse(await response.text()) as AuthResponse;

    await test.step('Verify response status and payload fields', async () => {
      expect(response.status()).toBe(201);

      const currentDate = new Date().toISOString().split('T')[0];
      const createdAtDate = payload.created_at.substring(0, 10);
      expect(createdAtDate).toBe(currentDate);
      expect(payload.user_email).toBe(email);
      expect(payload.user_id).toBe(userId);
      expect(payload.token).not.toBeNull();
      expect(payload.digest).not.toBeNull();
      expect(payload.ip).not.toBeNull();
      expect(payload.valid_until).not.toBeNull();
    });

    await test.step('Assert response payload does not contain unexpected fields', async () => {
      expect(Object.keys(payload).length).toBe(7);
    });
  });

  test('Authorize user with invalid credentials', async ({ authRequest }) => {
    const response = await authRequest.authorization(email, 'invalidPassword');
    expect(response.status()).toBe(403);
  });

  test('Authorize user with invalid email', async ({ authRequest }) => {
    const invalidEmail = generateRandomEmail();
    const response = await authRequest.authorization(invalidEmail, password);
    expect(response.status()).toBe(403);
  });

  test('Authorize user with empty email', async ({ authRequest }) => {
    const response = await authRequest.authorization('', password);
    expect(response.status()).toBe(400);
  });

  test('Get users with Cluster Secret', async ({ authRequest }) => {
    const email = process.env.DEFAULT_USER_EMAIL.toLowerCase();
    const response = await authRequest.getUsersWithClusterSecret(userId);
    const payload = JSON.parse(await response.text()) as UsersResponse;

    expect(response.status()).toBe(200);
    expect(payload.users.length).toBe(1);

    for (const user of payload.users) {
      expect(user.created_at).toBeGreaterThanOrEqual(1736339701);
      expect(user.deleted_at).toBe(0);
      expect(user.id).toBe(userId);
      expect(user.display_name.toLowerCase()).toBe(email);
      expect(user.is_active).toBe(true);
      expect(user.type_id).toBe(1);
      expect(user.email).toBe(email);
      expect(user.verified).toBe(true);
      expect(user.scope_id).toBeNull();
      expect(user.slack_connected).toBe(false);
      expect(user.is_password_autogenerated).toBe(false);
      expect(user.jira_connected).toBe(false);
      expect(user.last_login).toBeGreaterThanOrEqual(1736339701);
    }
  });

  test('Get user with Cluster Secret but no user ID', async ({ authRequest }) => {
    const response = await authRequest.getUsersWithClusterSecret();
    expect(response.status()).toBe(401);
  });

  test('Get user with Cluster Secret and invalid user ID', async ({ authRequest }) => {
    const response = await authRequest.getUsersWithClusterSecret('invalidUserID');
    expect(response.status()).toBe(404);
  });

  test('Get users with bad cluster secret', async ({ authRequest }) => {
    const response = await authRequest.getUsersWithBadClusterSecret(userId);
    expect(response.status()).toBe(403);
  });
});
