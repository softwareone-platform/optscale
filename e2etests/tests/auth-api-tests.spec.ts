import { test } from "../fixtures/page.fixture";
import { expect } from "@playwright/test";
import {AuthResponse, UsersResponse} from "../types/api-response.types";
import {generateRandomEmail} from "../utils/random-data-generator";

test.describe.skip("Auth API tests @api_tests", {tag: "@api"}, () => {
    const email = process.env.DEFAULT_USER_EMAIL;
    const password = process.env.DEFAULT_USER_PASSWORD;
    const userId = process.env.DEFAULT_USER_ID;

    test("Set verification codes", async ({ baseRequest }) => {
        const response = await baseRequest.setVerificationCode(email, "123456");

        await test.step("Verify response status and payload fields", async () => {
            expect(response.status()).toBe(201);
        });
    });

    test("Authorize user payload", async ({ baseRequest }) => {
        const response = await baseRequest.authorization(email, password);
        const payload = JSON.parse(await response.text()) as AuthResponse;

        await test.step("Verify response status and payload fields", async () => {
            expect(response.status()).toBe(201);

            const currentDate = new Date().toISOString().split('T')[0];
            const createdAtDate = payload.created_at.substring(0, 10);
            expect(createdAtDate).toBe(currentDate);
            expect(payload.user_email).toBe(email);
            expect(payload.user_id).toBe(userId);
            expect(payload.token).not.toBeNull();
            expect(payload.digest).not.toBeNull();
            expect(payload.ip).not.toBeNull();
            expect(payload.valid_until).not.toBeNull();
        });

        await test.step("Assert response payload does not contain unexpected fields", async () => {
            expect(Object.keys(payload).length).toBe(7);
        });
    });

    test("Authorize user with invalid credentials", async ({ baseRequest }) => {
        const response = await baseRequest.authorization(email, 'invalidPassword');
        expect(response.status()).toBe(403);
    });

    test("Authorize user with invalid email", async ({ baseRequest }) => {
        const invalidEmail= generateRandomEmail();
        const response = await baseRequest.authorization(invalidEmail, password);
        expect(response.status()).toBe(403);
    })

    test("Authorize user with empty email", async ({ baseRequest }) => {
        const response = await baseRequest.authorization('', password);
        expect(response.status()).toBe(400);
    })

    test("Get users with Cluster Secret", async ({ baseRequest }) => {
        const email = process.env.DEFAULT_USER_EMAIL.toLowerCase();
        const response = await baseRequest.getUsersWithClusterSecret(userId);
        const payload = JSON.parse(await response.text()) as UsersResponse;

        expect(response.status()).toBe(200);
        expect(payload.users.length).toBe(1);
        for(const user of payload.users) {
            expect(user.created_at).toBeGreaterThanOrEqual(1736339701);
            expect(user.deleted_at).toBe(0);
            expect(user.id).toBe(userId);
            expect(user.display_name.toLowerCase()).toBe(email);
            expect(user.is_active).toBe(true);
            expect(user.type_id).toBe(1);
            expect(user.email).toBe(email);
            expect(user.verified).toBe(true);
            expect(user.scope_id).toBeNull();
            expect(user.slack_connected).toBe(false);
            expect(user.is_password_autogenerated).toBe(false);
            expect(user.jira_connected).toBe(false);
            expect(user.last_login).toBeGreaterThanOrEqual(1736339701);
        }
    })

    test("Get user with Cluster Secret but no user ID", async ({ baseRequest }) => {
        const response = await baseRequest.getUsersWithClusterSecret();
        expect(response.status()).toBe(401);
    })

    test("Get user with Cluster Secret and invalid user ID", async ({ baseRequest }) => {
        const response = await baseRequest.getUsersWithClusterSecret('invalidUserID');
        expect(response.status()).toBe(404);
    })

    test("Get users with bad cluster secret", async ({ baseRequest }) => {
        const response = await baseRequest.getUsersWithBadClusterSecret(userId);
        expect(response.status()).toBe(403);
    })

});
